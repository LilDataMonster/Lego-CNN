from mrcnn.config import Config
class LegoConfig(Config):
    """Configuration for training on MS COCO.
    Derives from the base Config class and overrides values specific
    to the COCO dataset.
    """
    # Give the configuration a recognizable name
    NAME = "lego"

    # We use a GPU with 12GB memory, which can fit two images.
    # Adjust down if you use a smaller GPU.
    IMAGES_PER_GPU = 1

    # Uncomment to train on 8 GPUs (default is 1)
    GPU_COUNT = 2

    # Number of classes (including background)
    NUM_CLASSES = 1 + 42  # COCO has 80 classes

    # Define number of epochs
    NB_OF_EPOCHS = 5

    # Percent of positive ROIs used to train classifier/mask heads
    ROI_POSITIVE_RATIO = 0.33

    # Skip detections with < 90% confidence
    DETECTION_MIN_CONFIDENCE = 0.7                                  # default is 0.7, sollte kein Einfluss auf Training haben. Wird nur im DetectionLayer() verwendet, währen Inference.

    # Non-maximum suppression threshold for detection
    DETECTION_NMS_THRESHOLD = 0.3

    # Learning rate and momentum
    LEARNING_RATE = 0.001                                           # Default 0.001, in Retinanet I set it to 0.00001, if I use default mrcnn_class_losses do not get small enough, use 0.00001

    # Um die NN Grösse zu reduzieren, nimm kleinst mögliche Bildgrösse 
    # 800x600px die noch durch 64 teilbar ist -> 832
    IMAGE_MAX_DIM = 832

    # Enable and use RPN ROIs or disable RPN and use externally generated 
    # ROIs for training Keep this True for most situations. Set False if 
    # you want to train the head branches on ROI generated by code rather 
    # than the ROIs from the RPN. For example, to debug the classifier head 
    # without having to train the RPN. This esentially freezes the RPN
    # layers, disconnects the RPN losses from backpropagation and adds
    # a new input layer to replace the output from the RPN.
    USE_RPN_ROIS = True                                             # True = with RPN, False = externally generated

    PRE_NMS_LIMIT = 6000                                            # default 6000, for LPRN set to 2048
   
    # Build targets for training (anchors)
    RPN_TRAIN_ANCHOR_IOU_POS_TH = 0.9                               # Default 0.9, set slightly higher to show RPN to only accept anchors with high overlap
    RPN_TRAIN_ANCHOR_IOU_NEG_TH = 0.85                              # Default 0.85, set much higher, to ensure RPN ignores badly overlaping anchors for training I think with 0.6
                                                                    #              I should have still enough anchors

    RPN_NMS_THRESHOLD = 0.3                                         # Default 0.7, reduce to allow more anchors in final selection. Maybe I would exlude 
                                                                    # unintentially anchors that match the lego well. 

    # Length of square anchor side in pixels
    RPN_ANCHOR_SCALES = (80, 112, 144, 180, 256)

    # If USE_RPN_ROIS = False, choose to generate random ROIs or
    # ROIs from the GT bboxes for training. For inference it
    # will always use the GT boxes, hence this settin is ignored.
    USE_RANDOM_RPN_ROIS = False                                     # True = GT Boxes, False = Random
    
    # Enable and use the second stage (head branches including, classifier
    # bbo regressor and mask network). Set False if you want to train
    # RPN only. In this case USE_RPN_ROIS must be True. This will essentially
    # freeze all header layers and disconnect the losses from the header
    # leaving the RPN losses as only feedback for the backpropagation.
    USE_STAGE_TWO = True

    # Enable separate backbone for RPN and MRCNN (classifier, regression
    # and mask) network or use one backbone for all, like in the 
    # origninal Mask R-CNN implementation.
    USE_SEPARATE_BACKBONES = False

    # Choose backbone network architecture. Supported values are: resnet50, 
    # resnet101 and resnet18 whisch uses keras-resnet library 
    BACKBONE_RPN = "resnet18"
    BACKBONE_MRCNN = "resnet18"

    # This are the backbone filter configurations, the default settings 
    # and accordinng to wide residual network according to http://arxiv.org/pdf/1605.07146v1.pdf
    # This setting will change the Resnet filter configuration.
    BACKBONE_RESNET_BOTTLE_DEFAULT = {"S2": [64, 64, 256],   "S3": [128, 128, 512], "S4": [256, 256, 1024],   "S5": [512, 512, 2048]}
    BACKBONE_RESNET_BOTTLE_WIDER   = {"S2": [256, 256, 256], "S3": [512, 512, 512], "S4": [1024, 1024, 1024], "S5": [1024, 1024, 2048]}
    BACKBONE_RESNET_BASIC_DEFAULT  = {"S2": [64, 64],        "S3": [128, 128],      "S4": [256, 256],         "S5": [512, 512]}
    BACKBONE_RESNET_BASIC_WIDER    = {"S2": [160, 160],      "S3": [320, 320],      "S4": [640, 640],         "S5": [1280, 1280]}

    # Resnet backbone filter configuration
    BACKBONE_FITLERS_CONFIG = BACKBONE_RESNET_BASIC_DEFAULT

    #FPN_CLASSIF_FC_LAYERS_SIZE = 256                        # With LSTM cannot be more than 256                     
    #TRAIN_ROIS_PER_IMAGE = 20                               # Test in training (default 200), remove later
    POST_NMS_ROIS_INFERENCE = 1000                           # Test in interference (default 1000), remove later

    # Plot and save graph to file.
    PLOT_GRAPH = False                                       # None: to not plot, False: plot, True: plot nested / details
    
    USE_MINI_MASK = False
<<<<<<< Updated upstream

=======
>>>>>>> Stashed changes
